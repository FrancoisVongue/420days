import React, { useState, useMemo, useEffect } from 'react';
import dayjs from 'dayjs';
import { Plus, X, Target, TrendingUp, BarChart3, Settings, CheckSquare } from 'lucide-react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, ReferenceLine, Scatter, ComposedChart } from 'recharts';
import { Metric, Task } from '../types';
import { useApp } from '../context/AppContext';

interface MetricsChartProps {
  selectedDate: string;
  metrics: Metric[];
}

const CHART_COLORS = [
  '#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', 
  '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'
];

export const MetricsChart: React.FC<MetricsChartProps> = ({ selectedDate, metrics }) => {
  const { setMetrics, setTasks, state } = useApp();
  const { years, selectedYearId, tasks } = state;
  const selectedYear = years.find(y => y.id === selectedYearId);
  
  const [activeTab, setActiveTab] = useState<'chart' | 'metrics' | 'tasks'>('chart');
  const [showAddForm, setShowAddForm] = useState(false);
  const [metricToDelete, setMetricToDelete] = useState<string | null>(null);
  const [taskToDelete, setTaskToDelete] = useState<string | null>(null);
  const [newMetric, setNewMetric] = useState({
    name: '',
    targetValue: '',
    unit: '',
    epochId: '',
    tags: ''
  });
  const [newTask, setNewTask] = useState({
    name: '',
    description: '',
    dueDate: '',
    epochId: '',
    tags: ''
  });
  
  // Filter states
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [selectedEpochFilter, setSelectedEpochFilter] = useState<string>('');
  
  // Get all unique tags from metrics AND tasks
  const allTags = Array.from(new Set([
    ...metrics.flatMap(m => m.tags || []),
    ...tasks.flatMap(t => t.tags || [])
  ]));

  // Filter metrics based on selected tags and epoch
  const filteredMetrics = metrics.filter(metric => {
    // Filter by tags (OR logic - show if metric has ANY of selected tags)
    if (selectedTags.length > 0) {
      const hasSelectedTag = metric.tags?.some(tag => selectedTags.includes(tag));
      if (!hasSelectedTag) return false;
    }
    
    // Filter by epoch (show only metrics for selected epoch or all-year metrics)
    if (selectedEpochFilter) {
      if (metric.epochId && metric.epochId !== selectedEpochFilter) return false;
    }
    
    return true;
  });

  // Toggle tag selection
  const toggleTag = (tag: string) => {
    setSelectedTags(prev => 
      prev.includes(tag) 
        ? prev.filter(t => t !== tag)
        : [...prev, tag]
    );
  };

  const addMetric = () => {
    if (!newMetric.name || !newMetric.targetValue) return;

    const tagsArray = newMetric.tags
      .split(',')
      .map(tag => tag.trim())
      .filter(tag => tag.length > 0);

    const metric: Metric = {
      id: Date.now().toString(),
      name: newMetric.name,
      color: CHART_COLORS[metrics.length % CHART_COLORS.length],
      targetValue: parseFloat(newMetric.targetValue),
      entries: [],
      unit: newMetric.unit,
      epochId: newMetric.epochId || undefined,
      tags: tagsArray.length > 0 ? tagsArray : undefined
    };

    setMetrics([...metrics, metric]);
    setNewMetric({ name: '', targetValue: '', unit: '', epochId: '', tags: '' });
    setShowAddForm(false);
  };

  const removeMetric = (id: string) => {
    const metric = metrics.find(m => m.id === id);
    if (metric) {
      setMetricToDelete(id);
    }
  };

  const confirmDeleteMetric = () => {
    if (metricToDelete) {
      setMetrics(metrics.filter(m => m.id !== metricToDelete));
      setMetricToDelete(null);
    }
  };

  const cancelDeleteMetric = () => {
    setMetricToDelete(null);
  };

  // Task management functions
  const addTask = () => {
    if (!newTask.name || !newTask.dueDate) return;

    const tagsArray = newTask.tags
      .split(',')
      .map(tag => tag.trim())
      .filter(tag => tag.length > 0);

    const task: Task = {
      id: Date.now().toString(),
      name: newTask.name,
      description: newTask.description,
      dueDate: newTask.dueDate,
      tags: tagsArray.length > 0 ? tagsArray : undefined,
      epochId: newTask.epochId || undefined,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    setTasks([...tasks, task]);
    setNewTask({ name: '', description: '', dueDate: '', epochId: '', tags: '' });
    setShowAddForm(false);
  };

  const removeTask = (id: string) => {
    setTaskToDelete(id);
  };

  const confirmDeleteTask = () => {
    if (taskToDelete) {
      setTasks(tasks.filter(t => t.id !== taskToDelete));
      setTaskToDelete(null);
    }
  };

  const cancelDeleteTask = () => {
    setTaskToDelete(null);
  };

  // Prepare chart data for Recharts
  const chartData = useMemo(() => {
    if (filteredMetrics.length === 0) return [];

    // Get all unique dates from filtered metrics
    const allDates = new Set<string>();
    filteredMetrics.forEach(metric => {
      metric.entries.forEach(entry => {
        // Apply epoch filter
        if (selectedEpochFilter) {
          const selectedEpoch = selectedYear?.epochs.find(e => e.id === selectedEpochFilter);
          if (selectedEpoch && entry.date >= selectedEpoch.startDate && entry.date <= selectedEpoch.endDate) {
            allDates.add(entry.date);
          }
        } else {
          allDates.add(entry.date);
        }
      });
    });

    // Sort dates
    const sortedDates = Array.from(allDates).sort();

    // Build data array with all metrics for each date
    return sortedDates.map(date => {
      const dataPoint: any = {
        date,
        dateFormatted: dayjs(date).format('MMM D'),
      };

      // Add each metric's percentage for this date
      filteredMetrics.forEach(metric => {
        const entry = metric.entries.find(e => e.date === date);
        if (entry) {
          const percentage = (entry.value / metric.targetValue) * 100;
          dataPoint[metric.id] = percentage;
        }
      });

      return dataPoint;
    });
  }, [filteredMetrics, selectedEpochFilter, selectedYear]);

  // Prepare task points for chart
  const taskPoints = useMemo(() => {
    return tasks
      .filter(task => {
        // Filter by tags
        if (selectedTags.length > 0) {
          const hasSelectedTag = task.tags?.some(tag => selectedTags.includes(tag));
          if (!hasSelectedTag) return false;
        }
        
        // Filter by epoch
        if (selectedEpochFilter) {
          if (task.epochId && task.epochId !== selectedEpochFilter) return false;
        }
        
        return true;
      })
      .map(task => ({
        date: task.dueDate,
        dateFormatted: dayjs(task.dueDate).format('MMM D'),
        value: 100, // Tasks always at 100%
        name: task.name,
        isCompleted: !!task.completedDate,
        fill: task.completedDate ? '#10B981' : '#F59E0B',
      }));
  }, [tasks, selectedTags, selectedEpochFilter]);

  // Function to clear metrics data for a specific date
  const clearMetricsForDate = (date: string) => {
    setMetrics(metrics.map(metric => ({
      ...metric,
      entries: metric.entries.filter(entry => entry.date !== date)
    })));
  };

  // Listen for clear data events from other components
  useEffect(() => {
    const handleClearData = (event: CustomEvent) => {
      if (event.detail.date === selectedDate) {
        clearMetricsForDate(selectedDate);
      }
    };

    window.addEventListener('clearDayData', handleClearData as EventListener);
    return () => {
      window.removeEventListener('clearDayData', handleClearData as EventListener);
    };
  }, [selectedDate]);

  return (
    if (!svgRef.current || filteredMetrics.length === 0) return;

    const renderChart = () => {
      const svg = d3.select(svgRef.current);
      svg.selectAll('*').remove();

      const margin = { top: 20, right: 120, bottom: 40, left: 60 };
      
      // Get container dimensions dynamically
      const container = svgRef.current;
      if (!container) return;
      
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight || 500;
      
      const width = Math.max(containerWidth - margin.left - margin.right, 300);
      const height = Math.max(containerHeight - margin.top - margin.bottom, 300);

      // Set SVG dimensions
      svg
        .attr('width', containerWidth)
        .attr('height', containerHeight);

      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    // Get date range from filtered metrics
    const allDates = new Set<string>();
    const allPercentages: number[] = [];
    filteredMetrics.forEach(metric => {
      metric.entries.forEach(entry => {
        // If epoch filter is active, only include dates within that epoch
        if (selectedEpochFilter) {
          const selectedEpoch = selectedYear?.epochs.find(e => e.id === selectedEpochFilter);
          if (selectedEpoch && entry.date >= selectedEpoch.startDate && entry.date <= selectedEpoch.endDate) {
            allDates.add(entry.date);
          }
        } else {
          allDates.add(entry.date);
        }
      });
      metric.entries.forEach(entry => {
        const percentage = (entry.value / metric.targetValue) * 100;
        allPercentages.push(percentage);
      });
    });

    if (allDates.size === 0) return;

    const dateArray = Array.from(allDates).sort();
    const startDate = dayjs(dateArray[0]);
    const endDate = dayjs(dateArray[dateArray.length - 1]);

    // Always start from 0% and ensure 100% target is visible
    const yMin = 0;
    const maxPercentage = allPercentages.length > 0 ? Math.max(...allPercentages) : 100;
    // Ensure we always show at least up to 100% (target line), but go higher if needed
    const yMax = Math.max(100, maxPercentage * 1.1); // Add 10% padding above max value

    // Scales
    const xScale = d3.scaleTime()
      .domain([startDate.toDate(), endDate.toDate()])
      .range([0, width]);

    const yScale = d3.scaleLinear()
      .domain([yMin, yMax])
      .range([height, 0]);

    // Axes
    g.append('g')
      .attr('transform', `translate(0,${height})`)
      .call(d3.axisBottom(xScale).tickFormat((date: Date | d3.NumberValue) => d3.timeFormat('%b %d')(date as Date)));

    g.append('g')
      .call(d3.axisLeft(yScale).tickFormat(d => `${d}%`));

    // Target line at 100% (always visible since we always include 100% in range)
    g.append('line')
      .attr('x1', 0)
      .attr('x2', width)
      .attr('y1', yScale(100))
      .attr('y2', yScale(100))
      .attr('stroke', '#10B981')
      .attr('stroke-width', 2)
      .attr('stroke-dasharray', '5,5')
      .attr('opacity', 0.8);

    g.append('text')
      .attr('x', width - 5)
      .attr('y', yScale(100) - 5)
      .attr('text-anchor', 'end')
      .attr('fill', '#10B981')
      .attr('font-size', '12px')
      .attr('font-weight', 'bold')
      .text('Target');

    // Line generator
    const line = d3.line<{ date: Date; percentage: number }>()
      .x(d => xScale(d.date))
      .y(d => yScale(d.percentage))
      .curve(d3.curveMonotoneX);

    // Draw lines for each filtered metric
    filteredMetrics.forEach(metric => {
      if (metric.entries.length === 0) return;

      // Filter entries by epoch if selected
      let entries = metric.entries;
      if (selectedEpochFilter) {
        const selectedEpoch = selectedYear?.epochs.find(e => e.id === selectedEpochFilter);
        if (selectedEpoch) {
          entries = entries.filter(e => e.date >= selectedEpoch.startDate && e.date <= selectedEpoch.endDate);
        }
      }

      const lineData = entries
        .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime())
        .map(entry => ({
        date: dayjs(entry.date).toDate(),
        percentage: (entry.value / metric.targetValue) * 100
      }));

      if (lineData.length === 0) return;

      // Line path
      g.append('path')
        .datum(lineData)
        .attr('fill', 'none')
        .attr('stroke', metric.color)
        .attr('stroke-width', 2)
        .attr('d', line);

      // Data points
      g.selectAll(`.dot-${metric.id}`)
        .data(lineData)
        .enter().append('circle')
        .attr('class', `dot-${metric.id}`)
        .attr('cx', d => xScale(d.date))
        .attr('cy', d => yScale(d.percentage))
        .attr('r', 4)
        .attr('fill', metric.color)
        .attr('stroke', 'white')
        .attr('stroke-width', 2);
    });

    // Draw tasks as points at 100% on their due date
    const filteredTasks = tasks.filter(task => {
      // Filter by tags (OR logic)
      if (selectedTags.length > 0) {
        const hasSelectedTag = task.tags?.some(tag => selectedTags.includes(tag));
        if (!hasSelectedTag) return false;
      }
      
      // Filter by epoch
      if (selectedEpochFilter) {
        if (task.epochId && task.epochId !== selectedEpochFilter) return false;
      }
      
      return true;
    });

    filteredTasks.forEach(task => {
      const taskDate = dayjs(task.dueDate).toDate();
      
      // Only draw if task date is within the visible date range
      if (taskDate >= startDate.toDate() && taskDate <= endDate.toDate()) {
        const isCompleted = !!task.completedDate;
        
        // Draw task as a point at 100%
        g.append('circle')
          .attr('cx', xScale(taskDate))
          .attr('cy', yScale(100))
          .attr('r', 6)
          .attr('fill', isCompleted ? '#10B981' : '#F59E0B')
          .attr('stroke', 'white')
          .attr('stroke-width', 2)
          .attr('opacity', 0.9)
          .style('cursor', 'pointer')
          .append('title')
          .text(`${task.name}\nDue: ${dayjs(task.dueDate).format('MMM D, YYYY')}${isCompleted ? '\nâœ“ Completed' : ''}`);
      }
    });

    // Create tooltip
    const tooltip = d3.select('body')
      .append('div')
      .attr('class', 'metrics-chart-tooltip')
      .style('position', 'absolute')
      .style('visibility', 'hidden')
      .style('background', 'rgba(0, 0, 0, 0.9)')
      .style('color', 'white')
      .style('padding', '12px')
      .style('border-radius', '8px')
      .style('font-size', '13px')
      .style('pointer-events', 'none')
      .style('z-index', '1000')
      .style('box-shadow', '0 4px 12px rgba(0, 0, 0, 0.3)')
      .style('max-width', '300px');

    // Create invisible overlay for mouse tracking
    const overlay = g.append('rect')
      .attr('width', width)
      .attr('height', height)
      .attr('fill', 'none')
      .attr('pointer-events', 'all')
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      .on('mousemove', function(event: any) {
        // Overlay is used for mouse tracking - reference to satisfy linter
        void overlay;
        const [mouseX] = d3.pointer(event);
        const hoveredDate = xScale.invert(mouseX);
        
        // Find the closest date with data
        let closestDate: Date | null = null;
        let minDistance = Infinity;
        
        filteredMetrics.forEach(metric => {
          metric.entries.forEach(entry => {
            const entryDate = dayjs(entry.date).toDate();
            const distance = Math.abs(entryDate.getTime() - hoveredDate.getTime());
            if (distance < minDistance) {
              minDistance = distance;
              closestDate = entryDate;
            }
          });
        });
        
        if (!closestDate || minDistance > 7 * 24 * 60 * 60 * 1000) { // 7 days threshold
          tooltip.style('visibility', 'hidden');
          return;
        }
        
        const closestDateStr = dayjs(closestDate).format('YYYY-MM-DD');
        
        // Collect all metrics data for this date
        const tooltipData: Array<{
          name: string;
          value: number;
          target: number;
          percentage: number;
          color: string;
          unit: string;
        }> = [];
        
        filteredMetrics.forEach(metric => {
          const entry = metric.entries.find(e => e.date === closestDateStr);
          if (entry) {
            tooltipData.push({
              name: metric.name,
              value: entry.value,
              target: metric.targetValue,
              percentage: (entry.value / metric.targetValue) * 100,
              color: metric.color,
              unit: metric.unit || ''
            });
          }
        });
        
        if (tooltipData.length === 0) {
          tooltip.style('visibility', 'hidden');
          return;
        }
        
        // Build tooltip content
        const tooltipContent = `
          <div style="font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.3); padding-bottom: 4px;">
            ${dayjs(closestDate).format('MMM D, YYYY')}
          </div>
          ${tooltipData.map(data => `
            <div style="margin-bottom: 6px; display: flex; align-items: center;">
              <div style="width: 12px; height: 12px; background-color: ${data.color}; border-radius: 50%; margin-right: 8px; flex-shrink: 0;"></div>
              <div style="flex: 1;">
                <div style="font-weight: 500;">${data.name}</div>
                <div style="font-size: 12px; color: #ccc; margin-top: 1px;">
                  ${data.value}${data.unit} / ${data.target}${data.unit} (${data.percentage.toFixed(1)}%)
                </div>
              </div>
            </div>
          `).join('')}
        `;
        
        tooltip
          .style('visibility', 'visible')
          .html(tooltipContent);
        
        // Position tooltip
        const [pageX, pageY] = d3.pointer(event, document.body);
        tooltip
          .style('top', (pageY - 10) + 'px')
          .style('left', (pageX + 15) + 'px');
      })
      .on('mouseout', function() {
        tooltip.style('visibility', 'hidden');
      });

    // Legend
    const legend = g.append('g')
      .attr('transform', `translate(${width + 10}, 20)`);

    filteredMetrics.forEach((metric, i) => {
      const legendItem = legend.append('g')
        .attr('transform', `translate(0, ${i * 30})`);

      legendItem.append('line')
        .attr('x1', 0)
        .attr('x2', 15)
        .attr('y1', 0)
        .attr('y2', 0)
        .attr('stroke', metric.color)
        .attr('stroke-width', 2);

      // Add text with wrapping for long names
      const legendText = legendItem.append('text')
        .attr('x', 20)
        .attr('y', 0)
        .attr('dy', '0.35em')
        .attr('font-size', '12px')
        .style('max-width', '100px') // Limit width to force wrapping
        .text(metric.name);

      // Simple text wrapping for long metric names
      const text = legendText.node();
      if (text) {
        const textContent = text.textContent || '';
        
        // Simple truncation with ellipsis for very long names
        if (textContent.length > 15) {
          legendText.text(textContent.substring(0, 12) + '...');
        }
        
        // Add title attribute for hover tooltip
        legendText.attr('title', metric.name);
      }
    });
    };

    // Initial render
    renderChart();

    // Add resize listener
    const handleResize = () => {
      renderChart();
    };

    window.addEventListener('resize', handleResize);

    // Cleanup function
    return () => {
      d3.select('body').selectAll('.metrics-chart-tooltip').remove();
      window.removeEventListener('resize', handleResize);
    };

  }, [filteredMetrics, selectedDate, activeTab, selectedEpochFilter, selectedYear, tasks]);

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-3 h-full flex flex-col overflow-hidden">
      <div className="flex items-center justify-between mb-3 flex-shrink-0">
        <h2 className="text-lg font-bold text-gray-900">Progress Metrics</h2>
      </div>

      {/* Tabs */}
      <div className="flex space-x-1 mb-3 flex-shrink-0">
        <button
          onClick={() => setActiveTab('chart')}
          className={`flex items-center space-x-2 px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
            activeTab === 'chart'
              ? 'bg-blue-600 text-white'
              : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
          }`}
        >
          <BarChart3 className="w-4 h-4" />
          <span>Chart</span>
        </button>
        <button
          onClick={() => setActiveTab('metrics')}
          className={`flex items-center space-x-2 px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
            activeTab === 'metrics'
              ? 'bg-blue-600 text-white'
              : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
          }`}
        >
          <Settings className="w-4 h-4" />
          <span>Metrics</span>
        </button>
        <button
          onClick={() => setActiveTab('tasks')}
          className={`flex items-center space-x-2 px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
            activeTab === 'tasks'
              ? 'bg-blue-600 text-white'
              : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
          }`}
        >
          <CheckSquare className="w-4 h-4" />
          <span>Tasks</span>
        </button>
      </div>

      {/* Tab Content */}
      <div className="flex-1 min-h-0 flex flex-col overflow-hidden">
        {activeTab === 'chart' ? (
          /* Chart View */
          <div className="flex-1 flex flex-col min-h-0 gap-3">
            {/* Filters for Chart */}
            {metrics.length > 0 && (
              <div className="flex flex-col gap-2 flex-shrink-0">
                {/* Tags Filter */}
                {allTags.length > 0 && (
                  <div className="flex items-center gap-2 flex-wrap">
                    <span className="text-sm font-medium text-gray-700">Tags:</span>
                    {allTags.map(tag => (
                      <button
                        key={tag}
                        onClick={() => toggleTag(tag)}
                        className={`px-2 py-1 text-xs rounded-full transition-colors ${
                          selectedTags.includes(tag)
                            ? 'bg-blue-600 text-white'
                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                        }`}
                      >
                        {tag}
                      </button>
                    ))}
                    {selectedTags.length > 0 && (
                      <button
                        onClick={() => setSelectedTags([])}
                        className="px-2 py-1 text-xs text-red-600 hover:text-red-700"
                      >
                        Clear
                      </button>
                    )}
                  </div>
                )}
                
                {/* Epoch Filter */}
                {selectedYear && selectedYear.epochs.length > 0 && (
                  <div className="flex items-center gap-2">
                    <span className="text-sm font-medium text-gray-700">Epoch:</span>
                    <select
                      value={selectedEpochFilter}
                      onChange={(e) => setSelectedEpochFilter(e.target.value)}
                      className="px-3 py-1 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                      <option value="">All epochs</option>
                      {selectedYear.epochs.map(epoch => (
                        <option key={epoch.id} value={epoch.id}>{epoch.name}</option>
                      ))}
                    </select>
                  </div>
                )}
              </div>
            )}
            
            {/* Chart Area */}
            <div className="flex-1 min-h-0">
            {metrics.length > 0 ? (
              <div className="w-full h-full flex items-center justify-center">
                <svg ref={svgRef} width="100%" height="100%" className="border border-gray-200 rounded" />
              </div>
            ) : (
              <div className="text-center py-12 text-gray-500">
                <TrendingUp className="w-12 h-12 mx-auto mb-4 text-gray-300" />
                <p className="mb-4">No metrics added yet.</p>
                <button
                  onClick={() => setActiveTab('metrics')}
                  className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                >
                  Add Your First Metric
                </button>
              </div>
            )}
          </div>
          </div>
        ) : activeTab === 'metrics' ? (
          /* Metrics Management View */
          <div className="flex-1 flex flex-col gap-3 overflow-hidden">
            {/* Add Metric Button */}
            <div className="flex justify-between items-center flex-shrink-0">
              <p className="text-sm text-gray-600">Manage your metrics and add data points</p>
              <button
                onClick={() => setShowAddForm(true)}
                className="flex items-center space-x-2 px-3 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors text-sm"
              >
                <Plus className="w-4 h-4" />
                <span>Add Metric</span>
              </button>
            </div>

            {/* Add Metric Form */}
            {showAddForm && (
              <div className="p-3 bg-gray-50 rounded-lg border border-gray-200 flex-shrink-0">
                <div className="grid grid-cols-1 gap-3">
                  <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
                    <input
                      type="text"
                      placeholder="Metric name (e.g., Weight)"
                      value={newMetric.name}
                      onChange={(e) => setNewMetric({ ...newMetric, name: e.target.value })}
                      className="px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                    <input
                      type="number"
                      placeholder="Target value"
                      value={newMetric.targetValue}
                      onChange={(e) => setNewMetric({ ...newMetric, targetValue: e.target.value })}
                      className="px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                    <input
                      type="text"
                      placeholder="Unit (optional)"
                      value={newMetric.unit}
                      onChange={(e) => setNewMetric({ ...newMetric, unit: e.target.value })}
                      className="px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                    <select
                      value={newMetric.epochId}
                      onChange={(e) => setNewMetric({ ...newMetric, epochId: e.target.value })}
                      className="px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                      <option value="">All year</option>
                      {selectedYear?.epochs.map(epoch => (
                        <option key={epoch.id} value={epoch.id}>{epoch.name}</option>
                      ))}
                    </select>
                  </div>
                  
                  {/* Tags input with existing tags as buttons */}
                  <div className="flex flex-col gap-2">
                    <input
                      type="text"
                      placeholder="Add tags (comma-separated)"
                      value={newMetric.tags}
                      onChange={(e) => setNewMetric({ ...newMetric, tags: e.target.value })}
                      className="px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                    {allTags.length > 0 && (
                      <div className="flex items-center gap-2 flex-wrap">
                        <span className="text-xs text-gray-600">Quick add:</span>
                        {allTags.map(tag => (
                          <button
                            key={tag}
                            type="button"
                            onClick={() => {
                              const currentTags = newMetric.tags.split(',').map(t => t.trim()).filter(t => t);
                              if (!currentTags.includes(tag)) {
                                setNewMetric({ 
                                  ...newMetric, 
                                  tags: currentTags.length > 0 ? `${newMetric.tags}, ${tag}` : tag 
                                });
                              }
                            }}
                            className="px-2 py-1 text-xs bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300"
                          >
                            + {tag}
                          </button>
                        ))}
                      </div>
                    )}
                  </div>
                  
                  <div className="flex space-x-2">
                    <button
                      onClick={addMetric}
                      className="px-4 py-2 text-sm bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors"
                    >
                      Add Metric
                    </button>
                    <button
                      onClick={() => setShowAddForm(false)}
                      className="px-4 py-2 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-700 transition-colors"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Metrics List - Table View */}
            <div className="flex-1 overflow-y-auto">
              {metrics.length > 0 ? (
                <div className="overflow-x-auto">
                  <table className="w-full text-sm">
                    <thead className="bg-gray-100 sticky top-0">
                      <tr>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Default</th>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Name</th>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Tags</th>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Epoch</th>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Target</th>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Current</th>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Progress</th>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Actions</th>
                      </tr>
                    </thead>
                    <tbody>
                      {metrics.map(metric => {
                        const selectedEntry = metric.entries.find(e => e.date === selectedDate);
                        const currentValue = selectedEntry?.value || 0;
                        const percentage = metric.targetValue > 0 ? (currentValue / metric.targetValue) * 100 : 0;
                        const epochName = metric.epochId 
                          ? selectedYear?.epochs.find(e => e.id === metric.epochId)?.name || 'Unknown'
                          : 'All year';
                        
                        return (
                          <tr key={metric.id} className="border-b border-gray-200 hover:bg-gray-50">
                            <td className="px-3 py-2">
                              <input
                                type="checkbox"
                                checked={metric.isDefault || false}
                                onChange={(e) => {
                                  const updatedMetrics = metrics.map(m => ({
                                    ...m,
                                    isDefault: m.id === metric.id ? e.target.checked : false
                                  }));
                                  setMetrics(updatedMetrics);
                                }}
                                className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                                title="Set as default metric"
                              />
                            </td>
                            <td className="px-3 py-2">
                              <div className="flex items-center space-x-2">
                                <div
                                  className="w-3 h-3 rounded-full flex-shrink-0"
                                  style={{ backgroundColor: metric.color }}
                                />
                                <span className="font-medium text-gray-900">{metric.name}</span>
                              </div>
                            </td>
                            <td className="px-3 py-2">
                              {metric.tags && metric.tags.length > 0 ? (
                                <div className="flex gap-1 flex-wrap">
                                  {metric.tags.map(tag => (
                                    <span
                                      key={tag}
                                      className="px-2 py-0.5 text-xs bg-gray-200 text-gray-700 rounded-full"
                                    >
                                      {tag}
                                    </span>
                                  ))}
                                </div>
                              ) : (
                                <span className="text-gray-400 text-xs">-</span>
                              )}
                            </td>
                            <td className="px-3 py-2 text-gray-600">{epochName}</td>
                            <td className="px-3 py-2 text-gray-900">{metric.targetValue}{metric.unit}</td>
                            <td className="px-3 py-2 text-gray-900">{currentValue}{metric.unit}</td>
                            <td className="px-3 py-2">
                              <span className={`font-semibold ${percentage >= 100 ? 'text-green-600' : 'text-blue-600'}`}>
                                {percentage.toFixed(1)}%
                              </span>
                            </td>
                            <td className="px-3 py-2">
                              <button
                                onClick={() => removeMetric(metric.id)}
                                className="text-gray-400 hover:text-red-500 transition-colors"
                                title="Delete metric"
                              >
                                <X className="w-4 h-4" />
                              </button>
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                  <p className="text-xs text-gray-500 mt-3 px-3">
                    ðŸ’¡ Enter daily values using the sliders in the Daily Journal section
                  </p>
                </div>
              ) : (
                <div className="text-center py-12 text-gray-500">
                  <Target className="w-12 h-12 mx-auto mb-4 text-gray-300" />
                  <p className="mb-4">No metrics created yet.</p>
                  <p className="text-sm">Click "Add Metric" to start tracking your progress!</p>
                </div>
              )}
            </div>
          </div>
        ) : (
          /* Tasks Management View */
          <div className="flex-1 flex flex-col gap-3 overflow-hidden">
            {/* Add Task Button */}
            <div className="flex justify-between items-center flex-shrink-0">
              <p className="text-sm text-gray-600">Manage your tasks and deadlines</p>
              <button
                onClick={() => setShowAddForm(true)}
                className="flex items-center space-x-2 px-3 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors text-sm"
              >
                <Plus className="w-4 h-4" />
                <span>Add Task</span>
              </button>
            </div>

            {/* Add Task Form */}
            {showAddForm && (
              <div className="p-3 bg-gray-50 rounded-lg border border-gray-200 flex-shrink-0">
                <div className="grid grid-cols-1 gap-3">
                  <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
                    <input
                      type="text"
                      placeholder="Task name"
                      value={newTask.name}
                      onChange={(e) => setNewTask({ ...newTask, name: e.target.value })}
                      className="px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                    <input
                      type="date"
                      placeholder="Due date"
                      value={newTask.dueDate}
                      onChange={(e) => setNewTask({ ...newTask, dueDate: e.target.value })}
                      className="px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                    <select
                      value={newTask.epochId}
                      onChange={(e) => setNewTask({ ...newTask, epochId: e.target.value })}
                      className="px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                      <option value="">All year</option>
                      {selectedYear?.epochs.map(epoch => (
                        <option key={epoch.id} value={epoch.id}>{epoch.name}</option>
                      ))}
                    </select>
                    <input
                      type="text"
                      placeholder="Tags (comma-separated)"
                      value={newTask.tags}
                      onChange={(e) => setNewTask({ ...newTask, tags: e.target.value })}
                      className="px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                  </div>
                  
                  <textarea
                    placeholder="Description (optional)"
                    value={newTask.description}
                    onChange={(e) => setNewTask({ ...newTask, description: e.target.value })}
                    className="px-3 py-2 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
                    rows={2}
                  />
                  
                  {/* Tags quick-add buttons */}
                  {allTags.length > 0 && (
                    <div className="flex flex-col gap-2">
                      <div className="flex items-center gap-2 flex-wrap">
                        <span className="text-xs text-gray-600">Quick add:</span>
                        {allTags.map(tag => (
                          <button
                            key={tag}
                            type="button"
                            onClick={() => {
                              const currentTags = newTask.tags.split(',').map(t => t.trim()).filter(t => t);
                              if (!currentTags.includes(tag)) {
                                setNewTask({ 
                                  ...newTask, 
                                  tags: currentTags.length > 0 ? `${newTask.tags}, ${tag}` : tag 
                                });
                              }
                            }}
                            className="px-2 py-1 text-xs bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300"
                          >
                            + {tag}
                          </button>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  <div className="flex space-x-2">
                    <button
                      onClick={addTask}
                      className="px-4 py-2 text-sm bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors"
                    >
                      Add Task
                    </button>
                    <button
                      onClick={() => setShowAddForm(false)}
                      className="px-4 py-2 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-700 transition-colors"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Tasks List */}
            <div className="flex-1 overflow-y-auto">
              {tasks.length > 0 ? (
                <div className="overflow-x-auto">
                  <table className="w-full text-sm">
                    <thead className="bg-gray-100 sticky top-0">
                      <tr>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Name</th>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Due Date</th>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Epoch</th>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Status</th>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Tags</th>
                        <th className="px-3 py-2 text-left font-semibold text-gray-700">Actions</th>
                      </tr>
                    </thead>
                    <tbody>
                      {/* Active tasks (not completed) */}
                      {tasks.filter(t => !t.completedDate).map(task => {
                        const isOverdue = dayjs(task.dueDate).isBefore(dayjs(), 'day');
                        const taskEpoch = task.epochId ? selectedYear?.epochs.find(e => e.id === task.epochId) : null;
                        
                        return (
                          <tr key={task.id} className="border-b border-gray-200 hover:bg-gray-50">
                            <td className="px-3 py-2">
                              <div className="font-medium text-gray-900">{task.name}</div>
                              {task.description && (
                                <div className="text-xs text-gray-500 mt-0.5">{task.description}</div>
                              )}
                            </td>
                            <td className="px-3 py-2 text-gray-600">
                              {dayjs(task.dueDate).format('MMM D, YYYY')}
                            </td>
                            <td className="px-3 py-2">
                              {taskEpoch ? (
                                <span className="text-xs text-gray-700">{taskEpoch.name}</span>
                              ) : (
                                <span className="text-xs text-gray-400">All year</span>
                              )}
                            </td>
                            <td className="px-3 py-2">
                              {isOverdue ? (
                                <span className="px-2 py-1 text-xs bg-red-100 text-red-700 rounded-full">
                                  Overdue
                                </span>
                              ) : (
                                <span className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded-full">
                                  Pending
                                </span>
                              )}
                            </td>
                            <td className="px-3 py-2">
                              {task.tags && task.tags.length > 0 ? (
                                <div className="flex gap-1 flex-wrap">
                                  {task.tags.map(tag => (
                                    <span
                                      key={tag}
                                      className="px-2 py-0.5 text-xs bg-gray-200 text-gray-700 rounded-full"
                                    >
                                      {tag}
                                    </span>
                                  ))}
                                </div>
                              ) : (
                                <span className="text-gray-400 text-xs">-</span>
                              )}
                            </td>
                            <td className="px-3 py-2">
                              <button
                                onClick={() => removeTask(task.id)}
                                className="text-red-600 hover:text-red-700 transition-colors"
                                title="Delete task"
                              >
                                <X className="w-4 h-4" />
                              </button>
                            </td>
                          </tr>
                        );
                      })}
                      
                      {/* Completed tasks */}
                      {tasks.filter(t => !!t.completedDate).map(task => {
                        const taskEpoch = task.epochId ? selectedYear?.epochs.find(e => e.id === task.epochId) : null;
                        
                        return (
                          <tr key={task.id} className="border-b border-gray-200 hover:bg-gray-50 opacity-50">
                            <td className="px-3 py-2">
                              <div className="font-medium text-gray-500 line-through">{task.name}</div>
                              {task.description && (
                                <div className="text-xs text-gray-400 mt-0.5 line-through">{task.description}</div>
                              )}
                            </td>
                            <td className="px-3 py-2 text-gray-500 line-through">
                              {dayjs(task.dueDate).format('MMM D, YYYY')}
                            </td>
                            <td className="px-3 py-2">
                              {taskEpoch ? (
                                <span className="text-xs text-gray-500 line-through">{taskEpoch.name}</span>
                              ) : (
                                <span className="text-xs text-gray-400 line-through">All year</span>
                              )}
                            </td>
                            <td className="px-3 py-2">
                              <span className="px-2 py-1 text-xs bg-green-100 text-green-700 rounded-full opacity-70">
                                Completed
                              </span>
                            </td>
                            <td className="px-3 py-2">
                              {task.tags && task.tags.length > 0 ? (
                                <div className="flex gap-1 flex-wrap">
                                  {task.tags.map(tag => (
                                    <span
                                      key={tag}
                                      className="px-2 py-0.5 text-xs bg-gray-200 text-gray-500 rounded-full line-through"
                                    >
                                      {tag}
                                    </span>
                                  ))}
                                </div>
                              ) : (
                                <span className="text-gray-400 text-xs">-</span>
                              )}
                            </td>
                            <td className="px-3 py-2">
                              <button
                                onClick={() => removeTask(task.id)}
                                className="text-red-400 hover:text-red-500 transition-colors"
                                title="Delete task"
                              >
                                <X className="w-4 h-4" />
                              </button>
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
              ) : (
                <div className="text-center py-12 text-gray-500">
                  <CheckSquare className="w-12 h-12 mx-auto mb-4 text-gray-300" />
                  <p className="mb-4">No tasks created yet.</p>
                  <p className="text-sm">Click "Add Task" to start organizing your work!</p>
                </div>
              )}
            </div>
          </div>
        )}
      </div>

      {/* Delete Metric Confirmation Modal */}
      {metricToDelete && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4">
            <div className="flex items-center space-x-3 mb-4">
              <div className="flex items-center justify-center w-10 h-10 bg-red-100 rounded-full">
                <X className="w-5 h-5 text-red-600" />
              </div>
              <div>
                <h3 className="text-lg font-semibold text-gray-900">Delete Metric</h3>
                <p className="text-sm text-gray-600">This action cannot be undone</p>
              </div>
            </div>
            
            <div className="mb-6">
              <p className="text-gray-700 mb-2">
                Are you sure you want to delete the metric "
                <span className="font-semibold">
                  {metrics.find(m => m.id === metricToDelete)?.name}
                </span>
                "?
              </p>
              <div className="bg-red-50 border border-red-200 rounded-md p-3">
                <p className="text-red-800 text-sm font-medium">
                  âš ï¸ All historical data for this metric will be permanently lost
                </p>
                <p className="text-red-700 text-sm mt-1">
                  This includes {metrics.find(m => m.id === metricToDelete)?.entries.length || 0} data points
                </p>
              </div>
            </div>
            
            <div className="flex space-x-3 justify-end">
              <button
                onClick={cancelDeleteMetric}
                className="px-4 py-2 text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200 transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={confirmDeleteMetric}
                className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
              >
                Delete Metric
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Delete Task Confirmation Modal */}
      {taskToDelete && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4">
            <div className="flex items-center space-x-3 mb-4">
              <div className="flex items-center justify-center w-10 h-10 bg-red-100 rounded-full">
                <X className="w-5 h-5 text-red-600" />
              </div>
              <div>
                <h3 className="text-lg font-semibold text-gray-900">Delete Task</h3>
                <p className="text-sm text-gray-600">This action cannot be undone</p>
              </div>
            </div>
            
            <div className="mb-6">
              <p className="text-gray-700">
                Are you sure you want to delete the task "
                <span className="font-semibold">
                  {tasks.find(t => t.id === taskToDelete)?.name}
                </span>
                "?
              </p>
            </div>
            
            <div className="flex space-x-3 justify-end">
              <button
                onClick={cancelDeleteTask}
                className="px-4 py-2 text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200 transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={confirmDeleteTask}
                className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
              >
                Delete Task
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};